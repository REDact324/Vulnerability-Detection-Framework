from selenium import webdriver
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.chrome.options import Options
from PIL import Image
import io
import time

def capture_screenshot(ip_address, port):
  # Setup Chrome options
  chrome_options = Options()
  chrome_options.add_argument('--headless')  # Run in headless mode
  chrome_options.add_argument('--no-sandbox')
  chrome_options.add_argument('--disable-dev-shm-usage')

  # Specify the path to the chromedriver
  # service = ChromeService(executable_path='/path/to/chromedriver')  # Update with the actual path if not in PATH

  # Initialize the WebDriver
  driver = webdriver.Chrome(options=chrome_options)

  try:
    # Form the URL
    url = f'http://{ip_address}:{port}'
    print(f'Accessing {url}')

    # Open the URL
    driver.get(url)

    # Wait for the page to load
    time.sleep(8)  # Adjust this delay as needed

    # Capture the screenshot
    screenshot = driver.get_screenshot_as_png()
    image = Image.open(io.BytesIO(screenshot))

    return image

  except Exception as e:
    print(f'An error occurred: {e}')
    return None

  finally:
    # Close the WebDriver
    driver.quit()

def read_ip_addresses(file_path):
  with open(file_path, 'r') as file:
    lines = file.readlines()
  ip_port_pairs = [line.strip().split(':') for line in lines]
  return [(ip, int(port)) for ip, port in ip_port_pairs]

def provide_results(address, is_file=False):
  if is_file:
    file_path = address

    # Read IP addresses and ports from the file
    ip_addresses = read_ip_addresses(file_path)
  else:
    ip_addresses = address.strip().split(':')
    ip_addresses = [(ip_addresses[0], int(ip_addresses[1]))]

  images = []
  # Iterate over each IP address and port
  for ip_address, port in ip_addresses:
    # Capture the screenshot and get the screenshot
    image = capture_screenshot(ip_address, port)
    if image is not None:
      print(f"Screenshot captured and converted to tensor for {ip_address}:{port}.")
      images.append((image, ip_address, port))
      # Optionally, you can save the image to a file or further process it

  return images
